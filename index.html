<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Noise Seamless Procedural Clouds</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>html, body { margin: 0; height: 100%; overflow: hidden; }</style>
</head>
<body>
  <script>
    AFRAME.registerShader('seamless-clouds-3d', {
      schema: {
        time: { type: 'time', is: 'uniform' }
      },
      vertexShader: `
        varying vec3 vWorldDirection;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldDirection = normalize(worldPosition.xyz - cameraPosition);
          gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
      `,
      fragmentShader: `
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform float time;
        varying vec3 vWorldDirection;
        varying vec2 vUv;

        // Improved hash function for better distribution
        vec3 hash33(vec3 p3) {
          p3 = fract(p3 * vec3(.1031, .1030, .0973));
          p3 += dot(p3, p3.yxz + 33.33);
          return fract((p3.xxy + p3.yxx) * p3.zyx);
        }

        // Seamless 3D noise using periodic boundaries
        float noise3(vec3 p) {
          vec3 i = floor(p);
          vec3 f = fract(p);
          vec3 u = f * f * (3.0 - 2.0 * f);

          // Use modulo for seamless tiling
          vec3 i000 = mod(i, 256.0);
          vec3 i100 = mod(i + vec3(1,0,0), 256.0);
          vec3 i010 = mod(i + vec3(0,1,0), 256.0);
          vec3 i110 = mod(i + vec3(1,1,0), 256.0);
          vec3 i001 = mod(i + vec3(0,0,1), 256.0);
          vec3 i101 = mod(i + vec3(1,0,1), 256.0);
          vec3 i011 = mod(i + vec3(0,1,1), 256.0);
          vec3 i111 = mod(i + vec3(1,1,1), 256.0);

          float n000 = hash33(i000).x;
          float n100 = hash33(i100).x;
          float n010 = hash33(i010).x;
          float n110 = hash33(i110).x;
          float n001 = hash33(i001).x;
          float n101 = hash33(i101).x;
          float n011 = hash33(i011).x;
          float n111 = hash33(i111).x;

          float nx00 = mix(n000, n100, u.x);
          float nx10 = mix(n010, n110, u.x);
          float nx01 = mix(n001, n101, u.x);
          float nx11 = mix(n011, n111, u.x);

          float nxy0 = mix(nx00, nx10, u.y);
          float nxy1 = mix(nx01, nx11, u.y);

          return mix(nxy0, nxy1, u.z);
        }

        float fbm3(vec3 p) {
          float value = 0.0;
          float amplitude = 0.5;
          float frequency = 1.0;
          for (int i = 0; i < 4; i++) {
            value += amplitude * noise3(p * frequency);
            frequency *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        // Convert sphere coordinates to avoid pole singularities
        vec3 sphereToCartesian(vec2 uv) {
          float phi = uv.x * 6.28318530718; // 2*PI
          float theta = (uv.y - 0.5) * 3.14159265359; // PI
          
          return vec3(
            cos(theta) * cos(phi),
            sin(theta),
            cos(theta) * sin(phi)
          );
        }

        void main() {
          // Use normalized world direction for proper spherical sampling
          vec3 dir = normalize(vWorldDirection);
          
          float scale = 2.0;
          float speed = 0.0001;
          
          // Sample noise directly from world direction (no UV distortion)
          vec3 pos = dir * scale + vec3(
            time * speed,
            time * speed * 0.5,
            time * speed * 0.8
          );

          float clouds = fbm3(pos);
          
          // Remove horizon falloff - let clouds extend to equator
          // float horizon = abs(dir.y);
          // clouds *= smoothstep(0.0, 0.3, horizon);
          
          clouds = smoothstep(0.4, 0.7, clouds);

          vec3 baseColor = vec3(0.05, 0.15, 0.4);
          vec3 cloudColor = vec3(0.9, 0.95, 1.0);
          
          // Keep atmospheric perspective but reduce intensity
          float horizon = abs(dir.y);
          float atmosphere = 1.0 - smoothstep(0.0, 0.5, horizon);
          vec3 atmosphereColor = vec3(0.7, 0.8, 1.0);
          
          vec3 color = mix(baseColor, cloudColor, clouds);
          color = mix(color, atmosphereColor, atmosphere * 0.1);
          
          gl_FragColor = vec4(color, 1.0);
        }
      `
    });
  </script>

  <a-scene renderer="precision: mediump;" background="color: black">
    <!-- Procedural clouds sphere (background) -->
    <a-entity id="skyboxshader" geometry="primitive: sphere; radius: 5000; segmentsWidth: 64; segmentsHeight: 32"
              material="shader: seamless-clouds-3d; side: back;"
              scale="-1 1 1">
    </a-entity>
    
    <!-- Mountain silhouette sphere (foreground) -->
    <a-entity id="mountains" geometry="primitive: sphere; radius: 4999; segmentsWidth: 32; segmentsHeight: 16"
              material="src: mountains.png; transparent: true; alphaTest: 0.1; side: back; depthTest: false; renderOrder: 1;"
              scale="-1 1 1">
    </a-entity>
    
    <a-entity camera position="0 1.6 0" look-controls wasd-controls></a-entity>
  </a-scene>
</body>
</html>
